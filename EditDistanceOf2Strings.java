import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import static java.util.stream.Stream.*;
import static java.util.stream.Collectors.*;

public class EditDistanceOf2Strings
{
    private class Duo
    {
        int aIdx, bIdx;
        Duo(int a0Idx, int b0Idx) { aIdx = a0Idx; bIdx = b0Idx; }
        public String toString() { return String.format("(%d, %d)", aIdx, bIdx); }
    }

    private class Trio
    {
        int aIdx, bIdx, editDist;
        Trio(int a0Idx, int b0Idx, int editDist0) { aIdx = a0Idx; bIdx = b0Idx; editDist = editDist0; }
    }

    private String strA;
    private String strB;
    // store data generated by Dynamic Programming (DP) technique in memo 2d table
    private List<List<Integer>> memo;

    EditDistanceOf2Strings() {
        final Scanner readIp = new Scanner(System.in);
        final int numTests = readIp.nextInt();
        IntStream.rangeClosed(1, numTests)
            .forEach(test -> solveProblem(readIp));
    }

    private void solveProblem(final Scanner readIp) {
        strA = readIp.next();
        strB = readIp.next();
        initMemo();
        // Dynamic Programming
        dp();
        Deque<Duo> transitions = findTransitions();
        printTransitions(transitions);
        //debug();
    }

    private void initMemo() {
        memo = iterate(0, aIdx -> aIdx + 1)
            .limit(1 + strA.length())
            .map(aIdx -> iterate(0, bIdx -> bIdx + 1)
                .limit(1 + strB.length())
                .map(bIdx -> 0)
                .collect(toList()))
            .collect(toList());
    }

    private void dp() {
        dpAtleast1EmptyString();
        dpNonEmptyStrings();
    }

    private void dpAtleast1EmptyString() {
        IntStream.range(0, memo.size())
            .forEach(aIdx -> memo.get(aIdx).set(0, aIdx));
        IntStream.range(1, memo.get(0).size())
            .forEach(bIdx -> memo.get(0).set(bIdx, bIdx));
    }

    private void dpNonEmptyStrings() {
        IntStream.range(1, memo.size())
            .forEach(aIdx -> IntStream.range(1, memo.get(0).size())
                .forEach(bIdx -> computeMemoValue(aIdx, bIdx)));
    }

    private void computeMemoValue(final int aIdx, final int bIdx) {
        final int valAfterAddingChar = 1 + memo.get(aIdx).get(bIdx - 1);
        final int valAfterDeletingChar = 1 + memo.get(aIdx - 1).get(bIdx);
        final int valAfterReplacingChar = 1 + memo.get(aIdx - 1).get(bIdx - 1);

        IntUnaryOperator ifReplaceCharNotRequired =
            editDist -> strA.charAt(aIdx - 1) == strB.charAt(bIdx - 1) ? editDist - 1 : editDist;
        IntUnaryOperator ifDelCharCheaper =
            editDist -> valAfterDeletingChar < editDist ? valAfterDeletingChar : editDist;
        IntUnaryOperator ifAddCharCheaper =
            editDist -> valAfterAddingChar < editDist ? valAfterAddingChar : editDist;

        int newEditDist = IntStream.of(valAfterReplacingChar)
            .map(ifReplaceCharNotRequired)
            .map(ifDelCharCheaper)
            .map(ifAddCharCheaper)
            .sum();

        memo.get(aIdx).set(bIdx, newEditDist);
    }

    private Deque<Duo> findTransitions() {
        Deque<Duo> transitions = new ArrayDeque<>();
        Duo indices = new Duo(memo.size() - 1, memo.get(0).size() - 1);
        while (indices != null)
            indices = findNextTransition(transitions, indices);
        return transitions;
    }

    private Duo findNextTransition(final Deque<Duo> transitions, final Duo indices) {
        transitions.addFirst(indices);

        final int valAfterAddingChar = indices.bIdx != 0    ? 1 + memo.get(indices.aIdx).get(indices.bIdx - 1)
                                                            : Integer.MAX_VALUE;
        final int valAfterDeletingChar = indices.aIdx != 0  ? 1 + memo.get(indices.aIdx - 1).get(indices.bIdx)
                                                            : Integer.MAX_VALUE;
        final int valAfterReplacingChar = (indices.aIdx != 0) && (indices.bIdx != 0)
                                                ? 1 + memo.get(indices.aIdx - 1).get(indices.bIdx - 1)
                                                : Integer.MAX_VALUE;

        Predicate<Trio> anyNonEmptyString =
            state -> (indices.aIdx != 0) || (indices.bIdx != 0);
        Function<Trio,Trio> initTransitionAsReplaceChar =
            state -> (indices.aIdx != 0) && (indices.bIdx != 0)
                            ? new Trio(indices.aIdx - 1, indices.bIdx - 1, valAfterReplacingChar)
                            : state;
        Function<Trio,Trio> ifReplaceCharNotRequired =
            state -> (indices.aIdx != 0) && (indices.bIdx != 0)
                        && (strA.charAt(state.aIdx) == strB.charAt(state.bIdx))
                            ? new Trio(state.aIdx, state.bIdx, state.editDist - 1)
                            : state;
        Function<Trio,Trio> ifAddCharCheaper =
            state -> (indices.bIdx != 0) && (valAfterAddingChar < state.editDist)
                            ? new Trio(indices.aIdx, indices.bIdx - 1, valAfterAddingChar)
                            : state;
        Function<Trio,Trio> ifDelCharCheaper =
            state -> (indices.aIdx != 0) && (valAfterDeletingChar < state.editDist)
                            ? new Trio(indices.aIdx - 1, indices.bIdx, valAfterDeletingChar)
                            : state;

        return Stream.of(new Trio(-1, -1, Integer.MAX_VALUE))
            .filter(anyNonEmptyString)
            .map(initTransitionAsReplaceChar)
            .map(ifReplaceCharNotRequired)
            .map(ifAddCharCheaper)
            .map(ifDelCharCheaper)
            .map(state -> new Duo(state.aIdx, state.bIdx))
            .findFirst()
            .orElse(null);
    }

    private void printTransitions(final Deque<Duo> transitions) {
        pln("\n%,d is the edit distance from string \"%s\" to string \"%s\".",
            memo.get(memo.size() - 1).get(memo.get(0).size() - 1), strA, strB);

        // the empty slot at the start of array is to allow
        // "add char" OPs at the front of string A (source str)
        final String[] str_arr = " ".concat(strA).split("");
        pln("%s", transitions);

        pln("The transitions...");
        pln("%s", strA);

        transitions.stream()
            .reduce((indices1, indices2) -> {
                if ((indices2.aIdx == indices1.aIdx + 1) && (indices2.bIdx == indices1.bIdx + 1)) {
                    if (strA.charAt(indices1.aIdx) == strB.charAt(indices1.bIdx))
                        return indices2;
                    else {
                        str_arr[indices2.aIdx] = strB.charAt(indices1.bIdx) + str_arr[indices2.aIdx].substring(1);
                        p("replace: ");
                    }
                } else if (indices2.aIdx == indices1.aIdx + 1) {
                    str_arr[indices2.aIdx] = str_arr[indices2.aIdx].substring(1);
                    p("delete: ");
                } else {
                    str_arr[indices2.aIdx] += strB.charAt(indices1.bIdx);
                    p("add: ");
                }
                pln("%s", String.join("", str_arr));
                return indices2; });
    }

    private void debug() {
        pln("DEBUG -- memo :");
        IntStream.range(0, memo.size())
            .forEach(aIdx -> pln("%s", memo.get(aIdx)));
    }

    private void pln(String str, Object... vars) {
        p(str + "\n", vars);
    }

    private void p(String str, Object... vars) {
        System.out.printf(str, vars);
    }

    public static void main(String[] args) {
        new EditDistanceOf2Strings();
    }
}
